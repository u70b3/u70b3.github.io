---
title: 手撕代码-智能指针
date: 2020-11-02 23:28:35
tags: 
    - C++
    - 手撕代码
description: 手撕 C++ 的 auto_ptr、unique_ptr、shared_ptr
cover: 
sticky: 2
---

> 智能指针本质上就是 RAII 资源管理功能的自然展现而已。

## RAII
RAII，完整的英文是 *Resource Acquisition Is Initialization*，是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理（没有垃圾）。
 
例：工厂方法中，返回值类型是基类的指针或引用。


```c++

enum class shape_type {
  circle,
  triangle,
  rectangle,
  …
};

class shape { … };
class circle : public shape { … };
class triangle : public shape { … };
class rectangle : public shape { … };

shape* create_shape(shape_type type)
{
  //...
  switch (type) {
  case shape_type::circle:
    return new circle(…);
  case shape_type::triangle:
    return new triangle(…);
  case shape_type::rectangle:
    return new rectangle(…);
  //...
  }
}
```

使用 create_shape 的返回值时可能发生内存泄漏，解决方法是把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。
```c++
class shape_wrapper {
public:
  explicit shape_wrapper(shape* ptr = nullptr)
    : ptr_(ptr) {}
  ~shape_wrapper()
  {
    delete ptr_;
  }
  shape* get() const { return ptr_; }
private:
  shape* ptr_;
};

void foo()
{
  …
  shape_wrapper ptr_wrapper(
    create_shape(…));
  …
}
```
在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：
- 关闭文件（fstream 的析构）
- 释放同步锁（mutex等）
- 释放其他重要的系统资源（数据库连接等）

再例如：
```c++
// ❌
std::mutex mtx;
void some_func()
{
  mtx.lock();
  // 做需要同步的工作
  // 如果发生异常或提前返回，下面这句不会自动执行。
  mtx.unlock();
}

// ✅
std::mutex mtx;
void some_func()
{
  std::lock_guard<std::mutex> guard(mtx);
  // 做需要同步的工作
}
```
> 栈是 C++ 里最“自然”的内存使用方式，并且，使用基于栈和析构函数的 RAII，可以有效地对包括堆内存在内的系统资源进行统一管理。


## auto_ptr
简单改造上述使用 RAII 的 shape_wrapper 即可
- 模板化
- 易用性
  - `*` 运算符解引用
  - `->` 运算符指向对象成员
  - 像指针一样用在布尔表达式里
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 异常安全


```c++
class smart_ptr
{
public:
    explicit smart_ptr(T *ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr()
    {
        delete ptr_;
    }
    smart_ptr(smart_ptr &other)
    {
        ptr_ = other.release();
    }
    smart_ptr &operator=(smart_ptr &rhs)
    {
        smart_ptr(rhs).swap(*this);
        return *this;
    }
    T *get() const { return ptr_; }
    T &operator*() const { return *ptr_; }
    T *operator->() const { return ptr_; }
    operator bool() const { return ptr_; }

    T *release()
    {
        T *ptr = ptr_;
        ptr_ = nullptr;
        return ptr;
    }
    void swap(smart_ptr &rhs)
    {
        std::swap(ptr_, rhs.ptr_);
    }

private:
    T *ptr_;
};
```
这种实现即 C++98 `auto_ptr` 的定义，在 C++17 正式删除

## unique_ptr
在 `auto_ptr` 基础上实现
- 移动构造
- 指针子类转基类

```c++
#include <utility>  // std::swap/move
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr()
    {
        delete ptr_;
    }
    smart_ptr(smart_ptr&& other)
    {
        ptr_ = other.release();
    }
    smart_ptr& operator=(smart_ptr rhs)
    {
        rhs.swap(*this);
        return *this;
    }
    T* get() const { return ptr_; }
    T& operator*() const { return *ptr_; }
    T* operator->() const { return ptr_; }
    operator bool() const { return ptr_; }
    T* release()
    {
        T* ptr = ptr_;
        ptr_ = nullptr;
        return ptr;
    }
    void swap(smart_ptr& rhs)
    {
        std::swap(ptr_, rhs.ptr_);
    }

private:
    T* ptr_;
};
```

## shared_ptr
在 `unique_ptr` 基础上实现
- 引用计数
- 指针类型转换

```c++
#ifndef SMART_PTR_H
#define SMART_PTR_H

#include <atomic>   // std::atomic
#include <utility>  // std::swap

class shared_count {
public:
    shared_count() noexcept
        : count_(1)
    {
    }
    void add_count() noexcept
    {
        count_.fetch_add(1, std::memory_order_relaxed);
    }
    long reduce_count() noexcept
    {
        return --count_;
    }
    long get_count() const noexcept
    {
        return count_;
    }

private:
    std::atomic_long count_;
};

template <typename T>
class smart_ptr {
public:
    template <typename U>
    friend class smart_ptr;

    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr)
    {
        if (ptr) {
            shared_count_ = new shared_count();
        }
    }
    ~smart_ptr()
    {
        if (ptr_ && !shared_count_->reduce_count()) {
            delete ptr_;
            delete shared_count_;
        }
    }

    smart_ptr(const smart_ptr& other) noexcept
    {
        ptr_ = other.ptr_;
        if (ptr_) {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }
    template <typename U>
    smart_ptr(const smart_ptr<U>& other) noexcept
    {
        ptr_ = other.ptr_;
        if (ptr_) {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }
    template <typename U>
    smart_ptr(smart_ptr<U>&& other) noexcept
    {
        ptr_ = other.ptr_;
        if (ptr_) {
            shared_count_ = other.shared_count_;
            other.ptr_ = nullptr;
        }
    }
    template <typename U>
    smart_ptr(const smart_ptr<U>& other, T* ptr) noexcept
    {
        ptr_ = ptr;
        if (ptr_) {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }
    smart_ptr& operator=(smart_ptr rhs) noexcept
    {
        rhs.swap(*this);
        return *this;
    }

    T* get() const noexcept
    {
        return ptr_;
    }
    long use_count() const noexcept
    {
        if (ptr_) {
            return shared_count_->get_count();
        } else {
            return 0;
        }
    }
    void swap(smart_ptr& rhs) noexcept
    {
        std::swap(ptr_, rhs.ptr_);
        std::swap(shared_count_, rhs.shared_count_);
    }

    T& operator*() const noexcept
    {
        return *ptr_;
    }
    T* operator->() const noexcept
    {
        return ptr_;
    }
    operator bool() const noexcept
    {
        return ptr_;
    }

private:
    T* ptr_;
    shared_count* shared_count_;
};

template <typename T>
void swap(smart_ptr<T>& lhs, smart_ptr<T>& rhs) noexcept
{
    lhs.swap(rhs);
}

template <typename T, typename U>
smart_ptr<T> static_pointer_cast(const smart_ptr<U>& other) noexcept
{
    T* ptr = static_cast<T*>(other.get());
    return smart_ptr<T>(other, ptr);
}

template <typename T, typename U>
smart_ptr<T> reinterpret_pointer_cast(const smart_ptr<U>& other) noexcept
{
    T* ptr = reinterpret_cast<T*>(other.get());
    return smart_ptr<T>(other, ptr);
}

template <typename T, typename U>
smart_ptr<T> const_pointer_cast(const smart_ptr<U>& other) noexcept
{
    T* ptr = const_cast<T*>(other.get());
    return smart_ptr<T>(other, ptr);
}

template <typename T, typename U>
smart_ptr<T> dynamic_pointer_cast(const smart_ptr<U>& other) noexcept
{
    T* ptr = dynamic_cast<T*>(other.get());
    return smart_ptr<T>(other, ptr);
}

#endif // SMART_PTR_H
```
