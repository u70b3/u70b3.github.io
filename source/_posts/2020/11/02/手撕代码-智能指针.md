---
title: 手撕代码-智能指针
date: 2020-11-02 23:28:35
tags: 
    - C++
    - 手撕代码
description: 手撕 C++ 的 auto_ptr、unique_ptr、shared_ptr
cover: 
---

> 智能指针本质上就是 RAII 资源管理功能的自然展现而已。

## RAII
RAII，完整的英文是 *Resource Acquisition Is Initialization*，是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理（没有垃圾）。
 
例：工厂方法中，返回值类型是基类的指针或引用。


```c++

enum class shape_type {
  circle,
  triangle,
  rectangle,
  …
};

class shape { … };
class circle : public shape { … };
class triangle : public shape { … };
class rectangle : public shape { … };

shape* create_shape(shape_type type)
{
  //...
  switch (type) {
  case shape_type::circle:
    return new circle(…);
  case shape_type::triangle:
    return new triangle(…);
  case shape_type::rectangle:
    return new rectangle(…);
  //...
  }
}
```

使用 create_shape 的返回值时可能发生内存泄漏，解决方法是把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。
```c++
class shape_wrapper {
public:
  explicit shape_wrapper(shape* ptr = nullptr)
    : ptr_(ptr) {}
  ~shape_wrapper()
  {
    delete ptr_;
  }
  shape* get() const { return ptr_; }
private:
  shape* ptr_;
};

void foo()
{
  …
  shape_wrapper ptr_wrapper(
    create_shape(…));
  …
}
```
在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：
- 关闭文件（fstream 的析构）
- 释放同步锁（mutex等）
- 释放其他重要的系统资源（数据库连接等）

再例如：
```c++
// ❌
std::mutex mtx;
void some_func()
{
  mtx.lock();
  // 做需要同步的工作
  // 如果发生异常或提前返回，下面这句不会自动执行。
  mtx.unlock();
}

// ✅
std::mutex mtx;
void some_func()
{
  std::lock_guard<std::mutex> guard(mtx);
  // 做需要同步的工作
}
```
> 栈是 C++ 里最“自然”的内存使用方式，并且，使用基于栈和析构函数的 RAII，可以有效地对包括堆内存在内的系统资源进行统一管理。


## auto_ptr
简单改造上述使用 RAII 的 shape_wrapper 即可
- 模板化
- 易用性
  - `*` 运算符解引用
  - `->` 运算符指向对象成员
  - 像指针一样用在布尔表达式里
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 异常安全


```c++
class smart_ptr
{
public:
    explicit smart_ptr(T *ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr()
    {
        delete ptr_;
    }
    smart_ptr(smart_ptr &other)
    {
        ptr_ = other.release();
    }
    smart_ptr &operator=(smart_ptr &rhs)
    {
        smart_ptr(rhs).swap(*this);
        return *this;
    }
    T *get() const { return ptr_; }
    T &operator*() const { return *ptr_; }
    T *operator->() const { return ptr_; }
    operator bool() const { return ptr_; }

    T *release()
    {
        T *ptr = ptr_;
        ptr_ = nullptr;
        return ptr;
    }
    void swap(smart_ptr &rhs)
    {
        using std::swap;
        swap(ptr_, rhs.ptr_);
    }

private:
    T *ptr_;
};
```
这种实现即 C++98 `auto_ptr` 的定义，在 C++17 正式删除
## unique_ptr
在 `auto_ptr` 基础上实现
- 移动构造
- 指针子类转基类

```c++

```

## shared_ptr
在 `unique_ptr` 基础上实现
- 引用计数
- 指针类型转换

```c++
```